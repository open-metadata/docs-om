---
title: Python SDK for Tags
sidebarTitle: Tags
---

# Python SDK for Tags

In this guide, we will use the Python SDK to create Tags.

A **prerequisite** for this section is to have previously gone through the following [docs](/v1.12.x-SNAPSHOT/sdk/python).

In the following sections we will:
- Create a Database Service, a Database, a Schema and one Table,
- Create a Classification,
- Create a Tag for the Classification and add it to the Table.

## Creating the Entities

To prepare the necessary ingredients, execute the following steps.

### 1. Preparing the Client

```python
from metadata.sdk import configure

configure(host="http://localhost:8585/api", jwt_token="<token>")
```

### 2. Creating the Database Service

We are mocking a MySQL instance. Note how we need to pass the right configuration class `MysqlConnection`, as a
parameter for the generic `DatabaseConnection` type.

```python
from metadata.sdk import DatabaseServices
from metadata.generated.schema.api.services.createDatabaseService import (
    CreateDatabaseServiceRequest,
)
from metadata.generated.schema.entity.services.connections.database.common.basicAuth import (
    BasicAuth,
)
from metadata.generated.schema.entity.services.connections.database.mysqlConnection import (
    MysqlConnection,
)
from metadata.generated.schema.entity.services.databaseService import (
    DatabaseConnection,
    DatabaseServiceType,
)

db_service = CreateDatabaseServiceRequest(
    name="test-service-db-lineage",
    serviceType=DatabaseServiceType.Mysql,
    connection=DatabaseConnection(
        config=MysqlConnection(
            username="username",
            authType=BasicAuth(password="password"),
            hostPort="http://localhost:1234",
        )
    ),
)

db_service_entity = DatabaseServices.create(db_service)
```

### 3. Creating the Database

Any Entity that is created and linked to another Entity, has to hold the `fullyQualifiedName` to the Entity it
relates to. In this case, a Database is bound to a specific service.

```python
from metadata.sdk import Databases
from metadata.generated.schema.api.data.createDatabase import CreateDatabaseRequest

create_db = CreateDatabaseRequest(
    name="test-db",
    service=db_service_entity.fullyQualifiedName,
)

create_db_entity = Databases.create(create_db)
```

### 4. Creating the Schema

The same happens with the Schemas. They are related to a Database.

```python
from metadata.sdk import DatabaseSchemas
from metadata.generated.schema.api.data.createDatabaseSchema import (
    CreateDatabaseSchemaRequest,
)

create_schema = CreateDatabaseSchemaRequest(
    name="test-schema", database=create_db_entity.fullyQualifiedName
)

create_schema_entity = DatabaseSchemas.create(create_schema)
```

### 5. Creating the Table

We are doing a simple example with a single column.

```python
from metadata.sdk import Tables
from metadata.generated.schema.api.data.createTable import CreateTableRequest
from metadata.generated.schema.entity.data.table import Column, DataType

table = CreateTableRequest(
    name="my_table",
    databaseSchema=create_schema_entity.fullyQualifiedName,
    columns=[Column(name="id", dataType=DataType.BIGINT)],
)

table = Tables.create(table)
```

### 6. Creating the Classification

Classifications are the entities we use to group tag definitions. Let's create a sample one:

```python
from metadata.sdk import Classifications
from metadata.generated.schema.api.classification.createClassification import (
    CreateClassificationRequest,
)
from metadata.generated.schema.api.classification.createTag import CreateTagRequest

classification_request = CreateClassificationRequest(
    name="TestClassification",
    description="Sample classification.",
)

Classifications.create(classification_request)
```

### 7. Creating the Tag

Once there is an existing classification, we create tags within that given classification:

```python
from metadata.sdk import Tags

tag_request = CreateTagRequest(
    classification=classification_request.name,
    name="TestTag",
    description="Sample Tag.",
)

Tags.create(tag_request)
```

### 8. Tagging a Table

Now that we have the Tag, we can proceed and tag a specific asset. In this example, we'll
tag the Table we created above. For that, the API uses a PATCH request, but the Python SDK has
a helper method that handles most of the work:

```python
import requests

# PATCH the tag directly via the REST API
headers = {
    "Authorization": "Bearer <token>",
    "Content-Type": "application/json-patch+json",
}

patch = [
    {
        "op": "add",
        "path": "/tags/-",
        "value": {
            "tagFQN": "TestClassification.TestTag",
            "source": "Classification",
            "labelType": "Manual",
            "state": "Confirmed",
        },
    }
]

requests.patch(
    f"http://localhost:8585/api/v1/tables/{table.id}",
    headers=headers,
    json=patch,
)
```

If we now check the tags for the Table, the new tag will be appearing in there.

Note that if you control the Tag creation process when the Table metadata is generated, you can
assign tags in the `tags` property of `CreateTableRequest` directly â€” no PATCH needed.

### 9. Tagging a Column

The same PATCH approach works for column-level tags:

```python
import requests

headers = {
    "Authorization": "Bearer <token>",
    "Content-Type": "application/json-patch+json",
}

patch = [
    {
        "op": "add",
        "path": "/columns/0/tags/-",   # replace 0 with the column index
        "value": {
            "tagFQN": "TestClassification.TestTag",
            "source": "Classification",
            "labelType": "Manual",
            "state": "Confirmed",
        },
    }
]

requests.patch(
    f"http://localhost:8585/api/v1/tables/{table.id}",
    headers=headers,
    json=patch,
)
```
